<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>数据库篇 | happy的博客</title><meta name="author" content="happy"><meta name="copyright" content="happy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据库篇1. 隔离级别要求  掌握四种隔离级别与相关的错误现象  未提交读  读到其它事务未提交的数据（最新的版本）  错误现象：有脏读、不可重复读、幻读现象   脏读现象    tx1 tx2    set  session transaction isolation level read uncommitted;    start  transaction;    select  * from">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库篇">
<meta property="og:url" content="https://rrjjyy.github.io/2023/03/19/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/index.html">
<meta property="og:site_name" content="happy的博客">
<meta property="og:description" content="数据库篇1. 隔离级别要求  掌握四种隔离级别与相关的错误现象  未提交读  读到其它事务未提交的数据（最新的版本）  错误现象：有脏读、不可重复读、幻读现象   脏读现象    tx1 tx2    set  session transaction isolation level read uncommitted;    start  transaction;    select  * from">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.sj33.cn/uploads/allimg/201402/7-14022H14522550.png">
<meta property="article:published_time" content="2023-03-19T03:26:15.000Z">
<meta property="article:modified_time" content="2023-03-19T05:50:38.415Z">
<meta property="article:author" content="happy">
<meta property="article:tag" content="mysql">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.sj33.cn/uploads/allimg/201402/7-14022H14522550.png"><link rel="shortcut icon" href="/./img/touxiang.JPG"><link rel="canonical" href="https://rrjjyy.github.io/2023/03/19/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2f726bd13cc3867097194e16e4b7086b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "gukcvz5wss");</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据库篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-19 13:50:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/touxiang.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="happy的博客"><img class="site-icon" src="/./img/touxiang.JPG"/><span class="site-name">happy的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">数据库篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-19T03:26:15.000Z" title="发表于 2023-03-19 11:26:15">2023-03-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-19T05:50:38.415Z" title="更新于 2023-03-19 13:50:38">2023-03-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据库篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="数据库篇"><a href="#数据库篇" class="headerlink" title="数据库篇"></a>数据库篇</h1><h2 id="1-隔离级别"><a href="#1-隔离级别" class="headerlink" title="1. 隔离级别"></a>1. 隔离级别</h2><p><strong>要求</strong></p>
<ul>
<li>掌握四种隔离级别与相关的错误现象</li>
</ul>
<p><strong>未提交读</strong></p>
<ul>
<li><p>读到其它事务未提交的数据（最新的版本）</p>
</li>
<li><p>错误现象：有脏读、不可重复读、幻读现象</p>
</li>
</ul>
<p><strong>脏读现象</strong></p>
<table>
<thead>
<tr>
<th><strong>tx1</strong></th>
<th><strong>tx2</strong></th>
</tr>
</thead>
<tbody><tr>
<td>set  session transaction isolation level read uncommitted;</td>
<td></td>
</tr>
<tr>
<td>start  transaction;</td>
<td></td>
</tr>
<tr>
<td>select  * from account;  &#x2F;<em>两个账户都为 1000</em>&#x2F;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>start  transaction;</td>
</tr>
<tr>
<td></td>
<td>update  account set balance &#x3D; 2000 where accountNo&#x3D;1;</td>
</tr>
<tr>
<td>select  * from account; &#x2F;<em>1号账户2000, 2号账户1000</em>&#x2F;</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>tx2 未提交的情况下，tx1 仍然读取到了它的更改</li>
</ul>
<p><strong>提交读（RC）</strong></p>
<ul>
<li><p>读到其它事务已提交的数据（最新已提交的版本）</p>
</li>
<li><p>错误现象：有不可重复读、幻读现象</p>
</li>
<li><p>使用场景：希望看到最新的有效值</p>
</li>
</ul>
<p><strong>不可重复度现象</strong></p>
<table>
<thead>
<tr>
<th><strong>tx1</strong></th>
<th><strong>tx2</strong></th>
</tr>
</thead>
<tbody><tr>
<td>set  session transaction isolation level read committed;</td>
<td></td>
</tr>
<tr>
<td>start  transaction;</td>
<td></td>
</tr>
<tr>
<td>select  * from account; &#x2F;<em>两个账户都为 1000</em>&#x2F;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update  account set balance &#x3D; 2000 where accountNo&#x3D;1;</td>
</tr>
<tr>
<td>select  * from account; &#x2F;<em>1号账户2000, 2号账户1000</em>&#x2F;</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>tx1 在同一事务内，两次读取的结果不一致，当然，此时 tx2 的事务已提交</li>
</ul>
<p><strong>可重复读（RR）</strong> </p>
<ul>
<li><p>在事务范围内，多次读能够保证一致性（快照建立时最新已提交版本）</p>
</li>
<li><p>错误现象：有幻读现象，可以用加锁避免</p>
</li>
<li><p>使用场景：事务内要求更强的一致性，但看到的未必是最新的有效值</p>
</li>
</ul>
<p><strong>幻读现象</strong></p>
<table>
<thead>
<tr>
<th><strong>tx1</strong></th>
<th><strong>tx2</strong></th>
</tr>
</thead>
<tbody><tr>
<td>set  session transaction isolation level repeatable read;</td>
<td></td>
</tr>
<tr>
<td>start  transaction;</td>
<td></td>
</tr>
<tr>
<td>select  * from account; &#x2F;<em>存在 1,2 两个账户</em>&#x2F;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert  into account values(3, 1000);</td>
</tr>
<tr>
<td>select  * from account; &#x2F;<em>发现还是只有 1,2 两个账户</em>&#x2F;</td>
<td></td>
</tr>
<tr>
<td>insert  into account values(3, 5000);  &#x2F;* ERROR  1062 (23000): Duplicate entry ‘3’ for key ‘PRIMARY’  *&#x2F;</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>tx1 查询时并没有发现 3 号账户，执行插入时却发现主键冲突异常，就好像出现了幻觉一样</li>
</ul>
<p><strong>加锁避免幻读</strong></p>
<table>
<thead>
<tr>
<th><strong>tx1</strong></th>
<th><strong>tx2</strong></th>
</tr>
</thead>
<tbody><tr>
<td>set  session transaction isolation level repeatable read;</td>
<td></td>
</tr>
<tr>
<td>start  transaction;</td>
<td></td>
</tr>
<tr>
<td>select  * from account; &#x2F;<em>存在 1,2 两个账户</em>&#x2F;</td>
<td></td>
</tr>
<tr>
<td>select  * from account where accountNo&#x3D;3  for update;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert  into account values(3, 1000);  &#x2F;* 阻塞 *&#x2F;</td>
</tr>
<tr>
<td>insert  into account values(3, 5000);</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>在 for update 这行语句执行时，虽然此时 3 号账户尚不存在，但 MySQL 在 repeatable read 隔离级别下会用间隙锁，锁住 2 号记录与正无穷大之间的间隙</li>
<li>此时 tx2 想插入 3 号记录就不行了，被间隙锁挡住了</li>
</ul>
<p><strong>串行读</strong> </p>
<ul>
<li><p>在事务范围内，仅有读读可以并发，读写或写写会阻塞其它事务，用这种办法保证更强的一致性</p>
</li>
<li><p>错误现象：无</p>
</li>
</ul>
<p><strong>串行读避免幻读</strong></p>
<table>
<thead>
<tr>
<th><strong>tx1</strong></th>
<th><strong>tx2</strong></th>
</tr>
</thead>
<tbody><tr>
<td>set  session transaction isolation level serializable;</td>
<td></td>
</tr>
<tr>
<td>start  transaction;</td>
<td></td>
</tr>
<tr>
<td>select  * from account; &#x2F;* 存在 1,2 两个账户 *&#x2F;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert  into account values(3, 1000);  &#x2F;* 阻塞 *&#x2F;</td>
</tr>
<tr>
<td>insert  into account values(3, 5000);</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>串行读隔离级别下，普通的 select 也会加共享读锁，其它事务的查询可以并发，但增删改就只能阻塞了</li>
</ul>
<h2 id="2-快照读与当前读"><a href="#2-快照读与当前读" class="headerlink" title="2. 快照读与当前读"></a>2. 快照读与当前读</h2><p><strong>要求</strong></p>
<ul>
<li>理解快照读与当前读</li>
<li>了解快照产生的时机</li>
</ul>
<p><strong>当前读</strong></p>
<p>即读取最新提交的数据</p>
<ul>
<li>select … for update</li>
<li>select … lock in share mode</li>
<li>insert、update、delete，都会按最新提交的数据进行操作</li>
</ul>
<p>当前读本质上是基于锁的并发读操作</p>
<p><strong>快照读</strong></p>
<p>读取某一个快照建立时（可以理解为某一时间点）的数据，也称为一致性读。快照读主要体现在 select 时，而不同隔离级别下，select 的行为不同</p>
<ul>
<li><p>在 Serializable 隔离级别下 - 普通 select 也变成当前读，即加共享读锁</p>
</li>
<li><p>在 RC 隔离级别下 - 每次 select 都会建立新的快照</p>
</li>
<li><p>在 RR 隔离级别下</p>
<ul>
<li>事务启动后，首次 select 会建立快照</li>
<li>如果事务启动选择了 with consistent snapshot，事务启动时就建立快照</li>
<li>基于旧数据的修改操作，会重新建立快照</li>
</ul>
</li>
</ul>
<p>快照读本质上读取的是历史数据（原理是回滚段），属于无锁查询</p>
<p><strong>RR 下，快照建立时机 - 第一次 select 时</strong></p>
<table>
<thead>
<tr>
<th><strong>tx1</strong></th>
<th><strong>tx2</strong></th>
</tr>
</thead>
<tbody><tr>
<td>set  session transaction isolation level repeatable read;</td>
<td></td>
</tr>
<tr>
<td>start  transaction;</td>
<td></td>
</tr>
<tr>
<td>select  * from account;  &#x2F;* 此时建立快照，两个账户为 1000  *&#x2F;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update  account set balance &#x3D; 2000 where accountNo&#x3D;1;</td>
</tr>
<tr>
<td>select  * from account;  &#x2F;* 两个账户仍为 1000 *&#x2F;</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>快照一旦建立，以后的查询都基于此快照，因此 tx1 中第二次 select 仍然得到 1 号账户余额为 1000</li>
</ul>
<p>如果 tx2 的 update 先执行</p>
<table>
<thead>
<tr>
<th><strong>tx1</strong></th>
<th><strong>tx2</strong></th>
</tr>
</thead>
<tbody><tr>
<td>set  session transaction isolation level repeatable read;</td>
<td></td>
</tr>
<tr>
<td>start  transaction;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update  account set balance &#x3D; 2000 where accountNo&#x3D;1;</td>
</tr>
<tr>
<td>select  * from account; &#x2F;* 此时建立快照，1号余额已经为2000 *&#x2F;</td>
<td></td>
</tr>
</tbody></table>
<p><strong>RR 下，快照建立时机 - 事务启动时</strong></p>
<p>如果希望事务启动时就建立快照，可以添加 with consistent snapshot 选项</p>
<table>
<thead>
<tr>
<th><strong>tx1</strong></th>
<th><strong>tx2</strong></th>
</tr>
</thead>
<tbody><tr>
<td>set  session transaction isolation level repeatable read;</td>
<td></td>
</tr>
<tr>
<td>start  transaction with consistent snapshot; &#x2F;* 此时建立快照，两个账户为 1000  *&#x2F;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update  account set balance &#x3D; 2000 where accountNo&#x3D;1;</td>
</tr>
<tr>
<td>select  * from account; &#x2F;* 两个账户仍为 1000 *&#x2F;</td>
<td></td>
</tr>
</tbody></table>
<p><strong>RR 下，快照建立时机 - 修改数据时</strong></p>
<table>
<thead>
<tr>
<th><strong>tx1</strong></th>
<th><strong>tx2</strong></th>
</tr>
</thead>
<tbody><tr>
<td>set  session transaction isolation level repeatable read;</td>
<td></td>
</tr>
<tr>
<td>start  transaction;</td>
<td></td>
</tr>
<tr>
<td>select  * from account; &#x2F;* 此时建立快照，两个账户为 1000 *&#x2F;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update  account set balance&#x3D;balance+1000 where accountNo&#x3D;1;</td>
</tr>
<tr>
<td>update  account set balance&#x3D;balance+1000 where accountNo&#x3D;1;</td>
<td></td>
</tr>
<tr>
<td>select  * from account; &#x2F;* 1号余额为3000 *&#x2F;</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>tx1 内的修改必须重新建立快照，否则，就会发生丢失更新的问题</li>
</ul>
<h2 id="3-InnoDB-vs-MyISAM"><a href="#3-InnoDB-vs-MyISAM" class="headerlink" title="3. InnoDB vs MyISAM"></a>3. InnoDB vs MyISAM</h2><p><strong>要求</strong></p>
<ul>
<li>掌握 InnoDB 与 MyISAM 的主要区别</li>
<li>尤其注意它们在索引结构上的区别</li>
</ul>
<p><strong>InnoDB</strong></p>
<ul>
<li><p>索引分为聚簇索引与二级索引</p>
<ul>
<li>聚簇索引：主键值作为索引数据，叶子节点还包含了所有字段数据，索引和数据是存储在一起的</li>
<li>二级索引：除主键外的其它字段建立的索引称为二级索引。被索引的字段值作为索引数据，叶子节点还包含了主键值</li>
</ul>
</li>
<li><p>支持事务</p>
<ul>
<li>通过 undo log 支持事务回滚、当前读（多版本查询）</li>
<li>通过 redo log 实现持久性</li>
<li>通过两阶段提交实现一致性</li>
<li>通过当前读、锁实现隔离性</li>
</ul>
</li>
<li><p>支持行锁、间隙锁</p>
</li>
<li><p>支持外键</p>
</li>
</ul>
<p><strong>MyISAM</strong></p>
<ul>
<li><p>索引只有一种</p>
<ul>
<li>被索引字段值作为索引数据，叶子节点还包含了该记录数据页地址，数据和索引是分开存储的</li>
</ul>
</li>
<li><p>不支持事务，没有 undo log 和 redo log</p>
</li>
<li><p>仅支持表锁</p>
</li>
<li><p>不支持外键</p>
</li>
<li><p>会保存表的总行数</p>
</li>
</ul>
<p><strong>InnoDB 索引特点</strong></p>
<p>聚簇索引：主键值作为索引数据，叶子节点还包含了所有字段数据，索引和数据是存储在一起的</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901155308778.png" alt="image-20210901155308778"></p>
<ul>
<li>主键即 7369、7499、7521 等</li>
</ul>
<p>二级索引：除主键外的其它字段建立的索引称为二级索引。被索引的字段值作为索引数据，叶子节点还包含了主键值</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901155317460.png" alt="image-20210901155317460"></p>
<ul>
<li>上图中 800、950、1100 这些是工资字段的值，根据它们建立了二级索引</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901155327838.png" alt="image-20210901155327838"></p>
<ul>
<li>上图中，如果执行查询 <code>select empno, ename, sal from emp where sal = 800</code>，这时候可以利用二级索引定位到 800 这个工资，同时还能知道主键值 7369</li>
<li>但 select 字句中还出现了 ename 字段，在二级索引中不存在，因此需要根据主键值 7369 查询聚簇索引来获取 ename 的信息，这个过程俗称<strong>回表</strong></li>
</ul>
<p><strong>MyISAM 索引特点</strong></p>
<p>被索引字段值作为索引数据，叶子节点还包含了该记录数据页地址，数据和索引是分开存储的</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901155226621.png" alt="image-20210901155226621"></p>
<h2 id="4-索引"><a href="#4-索引" class="headerlink" title="4. 索引"></a>4. 索引</h2><p><strong>要求</strong></p>
<ul>
<li>了解常见索引与它们的适用场景，尤其是 B+Tree 索引的特点</li>
<li>掌握索引用于排序，以及失效情况</li>
<li>掌握索引用于筛选，以及失效情况</li>
<li>理解索引条件下推</li>
<li>理解二级索引覆盖</li>
</ul>
<h3 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h3><p><strong>常见索引</strong></p>
<ul>
<li><p>哈希索引</p>
<ul>
<li>理想时间复杂度为 $O(1)$</li>
<li>适用场景：适用于等值查询的场景，内存数据的索引</li>
<li>典型实现：Redis，MySQL 的 memory 引擎</li>
</ul>
</li>
<li><p>平衡二叉树索引 </p>
<ul>
<li>查询和更新的时间复杂度都是 $O(log_2(n))$</li>
<li>适用场景：适用于等值查询以及范围查询；适合内存数据的索引，但不适合磁盘数据的索引，可以认为<strong>树的高度决定了磁盘 I&#x2F;O 的次数</strong>，百万数据树高约为 20</li>
</ul>
</li>
<li><p>BTree 索引</p>
<ul>
<li>BTree 其实就是 n 叉树，分叉多意味着节点中的孩子（key）多，树高自然就降低了</li>
<li>分叉数由页大小和行（包括 key 与 value）大小决定<ul>
<li>假设页大小为 16k，每行 40 个字节，那么分叉数就为 16k &#x2F; 40 ≈ 410</li>
<li>而分叉为 410，则百万数据树高约为3，仅 3 次 I&#x2F;O 就能找到所需数据</li>
</ul>
</li>
<li><strong>局部性原理</strong>：每次 I&#x2F;O 按页为单位读取数据，把多个 <strong>key 相邻</strong>的行放在同一页中（每页就是树上一个节点），能进一步减少 I&#x2F;O</li>
</ul>
</li>
<li><p>B+ 树索引 </p>
<ul>
<li>在 BTree 的基础上做了改进，索引上只存储 key，这样能进一步增加分叉数，假设 key 占 13 个字节，那么一页数据分叉数可以到 1260，树高可以进一步下降为 2</li>
</ul>
</li>
</ul>
<blockquote>
<p><em><strong>树高计算公式</strong></em></p>
<ul>
<li>$log_{10}(N) &#x2F;  log_{10}(M)$ 其中 N 为数据行数，M 为分叉数</li>
</ul>
</blockquote>
<p><strong>BTree vs B+Tree</strong></p>
<ul>
<li>无论 BTree 还是 B+Tree，每个叶子节点到根节点距离都相同</li>
<li>BTree key 及 value 在每个节点上，无论叶子还是非叶子节点</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901170943656.png" alt="image-20210901170943656" style="zoom:80%;" />

<ul>
<li>B+Tree 普通节点只存 key，叶子节点才存储 key 和 value，因此分叉数可以更多<ul>
<li>不过也请注意，普通节点上的 key 有的会与叶子节点的 key 重复</li>
</ul>
</li>
<li>B+Tree 必须到达叶子节点才能找到 value</li>
<li>B+Tree 叶子节点用链表连接，可以方便范围查询及全表遍历</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901170954328.png" alt="image-20210901170954328" style="zoom:80%;" />

<blockquote>
<p>注：这两张图都是仅画了 key，未画 value</p>
</blockquote>
<p><strong>B+Tree 新增 key</strong></p>
<p>假设阶数（m）为5</p>
<ol>
<li><p>若为空树，那么直接创建一个节点，插入 key 即可，此时这个叶子结点也是根结点。例如，插入 5</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901174939408.png" alt="image-20210901174939408"></p>
</li>
<li><p>插入时，若当前结点 key 的个数小于阶数，则插入结束</p>
</li>
<li><p>依次插入 8、10、15，按 key 大小升序</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901175021697.png" alt="image-20210901175021697"></p>
</li>
<li><p>插入 16，这时到达了阶数限制，所以要进行分裂</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901175057315.png" alt="image-20210901175057315"></p>
</li>
<li><p><strong>叶子节点分裂规则</strong>：将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前 m&#x2F;2 个（2个）记录，右结点包含剩下的记录，将中间的 key 进位到父结点中。<strong>注意</strong>：中间的 key 仍会保留在叶子节点一份</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901175106713.png" alt="image-20210901175106713"></p>
</li>
<li><p>插入 17</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901175333804.png" alt="image-20210901175333804"></p>
</li>
<li><p>插入 18，这时当前结点的 key 个数到达 5，进行分裂</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901175352807.png" alt="image-20210901175352807"></p>
</li>
<li><p>分裂成两个结点，左结点 2 个记录，右结点 3 个记录，key 16 进位到父结点中</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901175413305.png" alt="image-20210901175413305"></p>
</li>
<li><p>插入 19、20、21、22、6、9</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901175440205.png" alt="image-20210901175440205"></p>
</li>
<li><p>插入 7，当前结点的 key 个数到达 5，需要分裂</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901175518737-16304901199481.png" alt="image-20210901175518737"></p>
</li>
<li><p>分裂后 key 7 进入到父结点中，这时父节点 key 个数也到达 5</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901175544893.png" alt="image-20210901175544893"></p>
</li>
<li><p><strong>非叶子节点分裂规则</strong>：左子结点包含前 (m-1)&#x2F;2 个 key，将中间的 key 进位到父结点中（<strong>不保留</strong>），右子节点包含剩余的 key</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901175617464.png" alt="image-20210901175617464"></p>
</li>
</ol>
<p><strong>B+Tree 查询 key</strong></p>
<p>以查询 15 为例</p>
<ul>
<li><p>第一次 I&#x2F;O</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901175721826.png" alt="image-20210901175721826"></p>
</li>
<li><p>第二次 I&#x2F;O</p>
<p><img src="/./../../../../../%E9%98%B6%E6%AE%B510%EF%BC%9A%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/0%E3%80%81%E7%AC%94%E8%AE%B0%E4%BB%A3%E7%A0%81%E8%B5%84%E6%96%99/day05-%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%AE%B2%E4%B9%89/img/image-20210901175738876-16304902605912.png" alt="image-20210901175738876"></p>
</li>
<li><p>第三次 I&#x2F;O</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901175801859.png" alt="image-20210901175801859"></p>
</li>
</ul>
<p><strong>B+Tree 删除叶子节点 key</strong></p>
<ol>
<li><p>初始状态</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901180320860.png" alt="image-20210901180320860"></p>
</li>
<li><p><strong>删完有富余</strong>。即删除后结点的key的个数 &gt; m&#x2F;2 – 1，删除操作结束，例如删除 22</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901180331158.png" alt="image-20210901180331158"></p>
</li>
<li><p><strong>删完没富余，但兄弟节点有富余</strong>。即兄弟结点 key 有富余（ &gt; m&#x2F;2 – 1 ），向兄弟结点借一个记录，同时替换父节点，例如删除 15</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901180356515.png" alt="image-20210901180356515"></p>
</li>
<li><p><strong>兄弟节点也不富余，合并兄弟叶子节点</strong>。即兄弟节点合并成一个新的叶子结点，并删除父结点中的key，将当前结点指向父结点，例如删除 7</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901180405393.png" alt="image-20210901180405393"></p>
</li>
<li><p>也需要删除非叶子节点中的 7，并替换父节点保证区间仍有效</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901180422491.png" alt="image-20210901180422491"></p>
</li>
<li><p>左右兄弟都不够借，合并</p>
<p><img src="/./../../../../../%E9%98%B6%E6%AE%B510%EF%BC%9A%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/0%E3%80%81%E7%AC%94%E8%AE%B0%E4%BB%A3%E7%A0%81%E8%B5%84%E6%96%99/day05-%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%AE%B2%E4%B9%89/img/image-20210901180446827.png" alt="image-20210901180446827"></p>
</li>
</ol>
<p><strong>B+Tree 删除非叶子节点 key</strong></p>
<p>接着上面的操作</p>
<ol>
<li><p>非叶子节点 key 的个数 &gt; m&#x2F;2 – 1，则删除操作结束，否则执行 2</p>
</li>
<li><p>若<strong>兄弟结点有富余</strong>，父结点 key 下移，兄弟结点 key 上移，删除结束，否则执行 3</p>
</li>
<li><p>若<strong>兄弟节点没富余</strong>，当前结点和兄弟结点及父结点合并成一个新的结点。重复 1</p>
<p><img src="/./../../../../../%E9%98%B6%E6%AE%B510%EF%BC%9A%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/0%E3%80%81%E7%AC%94%E8%AE%B0%E4%BB%A3%E7%A0%81%E8%B5%84%E6%96%99/day05-%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%AE%B2%E4%B9%89/img/image-20210901180511685.png" alt="image-20210901180511685"></p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210901180516139.png" alt="image-20210901180516139"></p>
</li>
</ol>
<h3 id="命中索引"><a href="#命中索引" class="headerlink" title="命中索引"></a>命中索引</h3><blockquote>
<p><strong>准备数据</strong></p>
<ol>
<li><p>修改 MySQL 配置文件，在 [mysqld] 下添加 secure_file_priv&#x3D; 重启 MySQL 服务器，让选项生效</p>
</li>
<li><p>执行 db.sql 内的脚本，建表</p>
</li>
<li><p>执行 <code>LOAD DATA INFILE &#39;D:\\big_person.txt&#39; INTO TABLE big_person;</code> 注意实际路径根据情况修改</p>
<ul>
<li>测试表 big_person（此表数据量较大，如果与其它表数据一起提供不好管理，故单独提供），数据行数 100 万条，列个数 15 列。为了更快速导入数据，这里采用了 load data infile 命令配合 *.txt 格式数据</li>
</ul>
</li>
</ol>
</blockquote>
<p><strong>索引用于排序</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 测试单列索引并不能在多列排序时加速 */</span></span><br><span class="line"><span class="keyword">create</span> index first_idx <span class="keyword">on</span> big_person(first_name);</span><br><span class="line"><span class="keyword">create</span> index last_idx <span class="keyword">on</span> big_person(last_name);</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> big_person <span class="keyword">order</span> <span class="keyword">by</span> last_name, first_name limit <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 多列排序需要用组合索引 */</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> big_person <span class="keyword">drop</span> index first_idx;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> big_person <span class="keyword">drop</span> index last_idx;</span><br><span class="line"><span class="keyword">create</span> index last_first_idx <span class="keyword">on</span> big_person(last_name,first_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 多列排序需要遵循最左前缀原则, 第1个查询可以利用索引，第2,3查询不能利用索引 */</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> big_person <span class="keyword">order</span> <span class="keyword">by</span> last_name, first_name limit <span class="number">10</span>; </span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> big_person <span class="keyword">order</span> <span class="keyword">by</span> first_name, last_name limit <span class="number">10</span>; </span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> big_person <span class="keyword">order</span> <span class="keyword">by</span> first_name limit <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 多列排序升降序需要一致，查询1可以利用索引，查询2不能利用索引*/</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> big_person <span class="keyword">order</span> <span class="keyword">by</span> last_name <span class="keyword">desc</span>, first_name <span class="keyword">desc</span> limit <span class="number">10</span>; </span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> big_person <span class="keyword">order</span> <span class="keyword">by</span> last_name <span class="keyword">desc</span>, first_name <span class="keyword">asc</span> limit <span class="number">10</span>; </span><br></pre></td></tr></table></figure>

<blockquote>
<p><em><strong>最左前缀原则</strong></em></p>
<p>若建立组合索引 (a,b,c)，则可以<strong>利用</strong>到索引的排序条件是：</p>
<ul>
<li>order by a</li>
<li>order by a, b</li>
<li>order by a, b, c</li>
</ul>
</blockquote>
<p><strong>索引用于 where 筛选</strong></p>
<ul>
<li>参考 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html">https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html</a></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 模糊查询需要遵循字符串最左前缀原则，查询2可以利用索引，查询1,3不能利用索引 */</span></span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> first_name <span class="keyword">LIKE</span> <span class="string">&#x27;dav%&#x27;</span> LIMIT <span class="number">5</span>;</span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;dav%&#x27;</span> LIMIT <span class="number">5</span>;</span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%dav&#x27;</span> LIMIT <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 组合索引需要遵循最左前缀原则，查询1,2可以利用索引，查询3,4不能利用索引 */</span></span><br><span class="line"><span class="keyword">create</span> index province_city_county_idx <span class="keyword">on</span> big_person(province,city,county);</span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> province <span class="operator">=</span> <span class="string">&#x27;上海&#x27;</span> <span class="keyword">AND</span> city<span class="operator">=</span><span class="string">&#x27;宜兰县&#x27;</span> <span class="keyword">AND</span> county<span class="operator">=</span><span class="string">&#x27;中西区&#x27;</span>;</span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> county<span class="operator">=</span><span class="string">&#x27;中西区&#x27;</span> <span class="keyword">AND</span> city<span class="operator">=</span><span class="string">&#x27;宜兰县&#x27;</span> <span class="keyword">AND</span> province <span class="operator">=</span> <span class="string">&#x27;上海&#x27;</span>;</span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> city<span class="operator">=</span><span class="string">&#x27;宜兰县&#x27;</span> <span class="keyword">AND</span> county<span class="operator">=</span><span class="string">&#x27;中西区&#x27;</span>;</span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> county<span class="operator">=</span><span class="string">&#x27;中西区&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数及计算问题，一旦在字段上应用了计算或函数，都会造成索引失效。查询2可以利用索引，查询1不能利用索引 */</span></span><br><span class="line"><span class="keyword">create</span> index birthday_idx <span class="keyword">on</span> big_person(birthday);</span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> ADDDATE(birthday,<span class="number">1</span>)<span class="operator">=</span><span class="string">&#x27;2005-02-10&#x27;</span>;</span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> birthday<span class="operator">=</span>ADDDATE(<span class="string">&#x27;2005-02-10&#x27;</span>,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 隐式类型转换问题</span></span><br><span class="line"><span class="comment">	* 查询1会发生隐式类型转换等价于在phone上应用了函数，造成索引失效</span></span><br><span class="line"><span class="comment">	* 查询2字段与值类型相同不会类型转换，可以利用索引</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">create</span> index phone_idx <span class="keyword">on</span> big_person(phone);</span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> phone <span class="operator">=</span> <span class="number">13000013934</span>;</span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> phone <span class="operator">=</span> <span class="string">&#x27;13000013934&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em><strong>最左前缀原则（leftmost prefix）</strong></em></p>
<p>若建立组合索引 (a,b,c)，则可以<strong>利用</strong>到索引的查询条件是：</p>
<ul>
<li>where a &#x3D; ?</li>
<li>where a &#x3D; ? and b &#x3D; ? （注意与条件的先后次序无关，也可以是 where b &#x3D; ? and a &#x3D; ?，只要出现即可）</li>
<li>where a &#x3D; ? and b &#x3D; ? and c &#x3D; ? （注意事项同上）</li>
</ul>
<p><strong>不能利用</strong>的例子：</p>
<ul>
<li>where b &#x3D; ?</li>
<li>where b &#x3D; ? and c &#x3D; ?</li>
<li>where c &#x3D; ?</li>
</ul>
<p>特殊情况：</p>
<ul>
<li>where a &#x3D; ? and c &#x3D; ?（a &#x3D; ? 会利用索引，但 c &#x3D; ? 不能利用索引加速，会触发索引条件下推）</li>
</ul>
</blockquote>
<p><strong>索引条件下推</strong></p>
<ul>
<li>参考 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/index-condition-pushdown-optimization.html">https://dev.mysql.com/doc/refman/8.0/en/index-condition-pushdown-optimization.html</a></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 查询 1,2,3,4 都能利用索引，但 4 相当于部分利用了索引，会触发索引条件下推 */</span></span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> province <span class="operator">=</span> <span class="string">&#x27;上海&#x27;</span>;</span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> province <span class="operator">=</span> <span class="string">&#x27;上海&#x27;</span> <span class="keyword">AND</span> city<span class="operator">=</span><span class="string">&#x27;嘉兴市&#x27;</span>;</span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> province <span class="operator">=</span> <span class="string">&#x27;上海&#x27;</span> <span class="keyword">AND</span> city<span class="operator">=</span><span class="string">&#x27;嘉兴市&#x27;</span> <span class="keyword">AND</span> county<span class="operator">=</span><span class="string">&#x27;中西区&#x27;</span>;</span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> province <span class="operator">=</span> <span class="string">&#x27;上海&#x27;</span> <span class="keyword">AND</span> county<span class="operator">=</span><span class="string">&#x27;中西区&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em><strong>索引条件下推</strong></em></p>
<ul>
<li>MySQL 执行条件判断的时机有两处：<ul>
<li>服务层（上层，不包括索引实现）</li>
<li>引擎层（下层，包括了索引实现，可以利用）</li>
<li>上面查询 4 中有 province 条件能够利用索引，在引擎层执行，但 county 条件仍然要交给服务层处理</li>
</ul>
</li>
<li>在 5.6 之前，服务层需要判断所有记录的 county 条件，性能非常低</li>
<li>5.6 以后，引擎层会先根据 province 条件过滤，满足条件的记录才在服务层处理 county 条件</li>
</ul>
</blockquote>
<p>我们现在用的是 5.6 以上版本，所以没有体会，可以用下面的语句关闭索引下推优化，再测试一下性能</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;index_condition_pushdown=off&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> province <span class="operator">=</span> <span class="string">&#x27;上海&#x27;</span> <span class="keyword">AND</span> county<span class="operator">=</span><span class="string">&#x27;中西区&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p><strong>二级索引覆盖</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> province <span class="operator">=</span> <span class="string">&#x27;上海&#x27;</span> <span class="keyword">AND</span> city<span class="operator">=</span><span class="string">&#x27;宜兰县&#x27;</span> <span class="keyword">AND</span> county<span class="operator">=</span> <span class="string">&#x27;中西区&#x27;</span>;</span><br><span class="line">explain <span class="keyword">SELECT</span> id,province,city,county <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> province <span class="operator">=</span> <span class="string">&#x27;上海&#x27;</span> <span class="keyword">AND</span> city<span class="operator">=</span><span class="string">&#x27;宜兰县&#x27;</span> <span class="keyword">AND</span> county<span class="operator">=</span><span class="string">&#x27;中西区&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>根据查询条件查询 1，2 都会先走二级索引，但是二级索引仅包含了 (province, city, county) 和 id 信息</p>
<ul>
<li>查询 1 是 select *，因此还有一些字段二级索引中没有，需要回表（查询聚簇索引）来获取其它字段信息</li>
<li>查询 2 的 select 中明确指出了需要哪些字段，这些字段在二级索引都有，就避免了回表查询</li>
</ul>
<p><strong>其它注意事项</strong></p>
<ul>
<li>表连接需要在连接字段上建立索引</li>
<li>不要迷信网上说法，具体情况具体分析</li>
</ul>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index first_idx <span class="keyword">on</span> big_person(first_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不会利用索引，因为优化器发现查询记录数太多，还不如直接全表扫描 */</span></span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> first_name <span class="operator">&gt;</span> <span class="string">&#x27;Jenni&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 会利用索引，因为优化器发现查询记录数不太多 */</span></span><br><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> big_person <span class="keyword">WHERE</span> first_name <span class="operator">&gt;</span> <span class="string">&#x27;Willia&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 同一字段的不同值利用 or 连接，会利用索引 */</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> big_person <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> id <span class="operator">=</span> <span class="number">190839</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不同字段利用 or 连接，会利用索引(底层分别用了两个索引) */</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> big_person <span class="keyword">where</span> first_name <span class="operator">=</span> <span class="string">&#x27;David&#x27;</span> <span class="keyword">or</span> last_name <span class="operator">=</span> <span class="string">&#x27;Thomas&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* in 会利用索引 */</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> big_person <span class="keyword">where</span> first_name <span class="keyword">in</span> (<span class="string">&#x27;Mark&#x27;</span>, <span class="string">&#x27;Kevin&#x27;</span>,<span class="string">&#x27;David&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">/* not in 不会利用索引的情况 */</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> big_person <span class="keyword">where</span> first_name <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;Mark&#x27;</span>, <span class="string">&#x27;Kevin&#x27;</span>,<span class="string">&#x27;David&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* not in 会利用索引的情况 */</span></span><br><span class="line">explain <span class="keyword">select</span> id <span class="keyword">from</span> big_person <span class="keyword">where</span> first_name <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;Mark&#x27;</span>, <span class="string">&#x27;Kevin&#x27;</span>,<span class="string">&#x27;David&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>以上实验基于 5.7.27，其它如 !&#x3D;、is null、is not null 是否使用索引都会跟版本、实际数据相关，以优化器结果为准</li>
</ul>
<h2 id="5-查询语句执行流程"><a href="#5-查询语句执行流程" class="headerlink" title="5. 查询语句执行流程"></a>5. 查询语句执行流程</h2><p><strong>要求</strong></p>
<ul>
<li>了解查询语句执行流程</li>
</ul>
<p><strong>执行 SQL 语句 select * from user where id &#x3D; 1 时发生了什么</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210902082718756.png" alt="image-20210902082718756"></p>
<ol>
<li><p>连接器：负责建立连接、检查权限、连接超时时间由 wait_timeout 控制，默认 8 小时</p>
</li>
<li><p>查询缓存：会将 SQL 和查询结果以键值对方式进行缓存，修改操作会以表单位导致缓存失效</p>
</li>
<li><p>分析器：词法、语法分析</p>
</li>
<li><p>优化器：决定用哪个索引，决定表的连接顺序等</p>
</li>
<li><p>执行器：根据存储引擎类型，调用存储引擎接口</p>
</li>
<li><p>存储引擎：数据的读写接口，索引、表都在此层实现</p>
</li>
</ol>
<h2 id="6-undo-log-与-redo-log"><a href="#6-undo-log-与-redo-log" class="headerlink" title="6. undo log 与 redo log"></a>6. undo log 与 redo log</h2><p><strong>要求</strong></p>
<ul>
<li>理解 undo log 的作用</li>
<li>理解 redo log 的作用</li>
</ul>
<p><strong>undo log</strong></p>
<ul>
<li>回滚数据，以行为单位，记录数据每次的变更，一行记录有多个版本并存</li>
<li>多版本并发控制，即快照读（也称为一致性读），让查询操作可以去访问历史版本</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210902083051903.png" alt="image-20210902083051903"></p>
<ol>
<li>每个事务会按照开始时间，分配一个单调递增的事务编号 trx id</li>
<li>每次事务的改动都会以行为单位记入回滚日志，包括当时的事务编号，改动的值等</li>
<li>查询操作，事务编号大于自己的数据是不可见的，事务编号小于等于自己的数据才是可见的<ul>
<li>例如图中红色事务看不到 trx id&#x3D;102 以及 trx id&#x3D;101 的数据，只有 trx id&#x3D;99 的数据对它可见</li>
</ul>
</li>
</ol>
<p><strong>redo log</strong></p>
<p>redo log 的作用主要是实现 ACID 中的持久性，保证提交的数据不丢失</p>
<ul>
<li>它记录了事务提交的变更操作，服务器意外宕机重启时，利用 redo log 进行回放，重新执行已提交的变更操作</li>
<li>事务提交时，首先将变更写入 redo log，事务就视为成功。至于数据页（表、索引）上的变更，可以放在后面慢慢做<ul>
<li>数据页上的变更宕机丢失也没事，因为 redo log 里已经记录了</li>
<li>数据页在磁盘上位置随机，写入速度慢，redo log 的写入是顺序的速度快</li>
</ul>
</li>
</ul>
<p>它由两部分组成，内存中的 redo log buffer，磁盘上的 redo log file</p>
<ul>
<li>redo log file 由一组文件组成，当写满了会循环覆盖较旧的日志，这意味着不能无限依赖 redo log，更早的数据恢复需要 binlog </li>
<li>buffer 和 file 两部分组成意味着，写入了文件才真正安全，同步策略由参数 innodb_flush_log_at_trx_commit  控制<ul>
<li>0 - 每隔 1s 将日志 write and flush 到磁盘 </li>
<li>1 - 每次事务提交将日志 write and flush（默认值）</li>
<li>2 - 每次事务提交将日志 write，每隔 1s flush 到磁盘，意味着 write 意味着写入操作系统缓存，如果 MySQL 挂了，而操作系统没挂，那么数据不会丢失</li>
</ul>
</li>
</ul>
<h2 id="7-锁"><a href="#7-锁" class="headerlink" title="7. 锁"></a>7. 锁</h2><p><strong>要求</strong></p>
<ul>
<li>了解全局锁</li>
<li>了解表级锁</li>
<li>掌握行级锁</li>
</ul>
<p><strong>全局锁</strong></p>
<p>用作全量备份时，保证<strong>表与表之间的数据一致性</strong></p>
<p>如果不加任何包含，数据备份时就可能产生不一致的情况，如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/rrjjyy/img/image-20210902090302805.png" alt="image-20210902090302805"></p>
<p>全局锁的语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock;	</span><br></pre></td></tr></table></figure>

<ul>
<li>使用全局读锁锁定所有数据库的所有表。这时会阻塞其它所有 DML 以及 DDL 操作，这样可以避免备份过程中的数据不一致。接下来可以执行备份，最后用 unlock tables 来解锁</li>
</ul>
<blockquote>
<p><em><strong>注意</strong></em></p>
<p>但 flush tables 属于比较重的操作，可以使用 –single-transaction 参数来完成不加锁的一致性备份（仅针对 InnoDB 引擎的表）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="comment">--single-transaction -uroot -p test &gt; 1.sql</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>表级锁 - 表锁</strong></p>
<ul>
<li>语法：加锁 lock tables 表名 read&#x2F;write，解锁 unlock tables</li>
<li>缺点：粒度较粗，在 InnoDB 引擎很少使用</li>
</ul>
<p><strong>表级锁 - 元数据锁</strong></p>
<ul>
<li><p>即 metadata-lock（MDL），主要是为<strong>了避免 DML 与 DDL 冲突</strong>，DML 的元数据锁之间不互斥</p>
</li>
<li><p>加元数据锁的几种情况</p>
<ul>
<li><code>lock tables read/write</code>，类型为 SHARED_READ_ONLY 和 SHARED_NO_READ_WRITE</li>
<li><code>alter table</code>，类型为 EXCLUSIVE，与其它 MDL 都互斥</li>
<li><code>select，select … lock in share mode</code>，类型为 SHARED_READ</li>
<li><code>insert，update，delete，select for update</code>，类型为 SHARED_WRITE</li>
</ul>
</li>
<li><p>查看元数据锁（适用于 MySQL 8.0 以上版本）</p>
<ul>
<li><code>select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks;</code></li>
</ul>
</li>
</ul>
<p><strong>表级锁 - IS（意向共享） 与 IX（意向排他）</strong></p>
<ul>
<li>主要是<strong>避免 DML 与表锁冲突</strong>，DML 主要目的是加行锁，为了让表锁不用检查每行数据是否加锁，加意向锁（表级）来减少表锁的判断，意向锁之间不会互斥</li>
<li>加意向表锁的几种情况<ul>
<li><code>select  … lock in share mode</code> 会加 IS 锁</li>
<li><code>insert，update，delete， select … for update</code> 会加 IX 锁</li>
</ul>
</li>
<li>查看意向表锁（适用于 MySQL 8.0 以上版本）<ul>
<li><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;</code></li>
</ul>
</li>
</ul>
<p><strong>行级锁</strong></p>
<ul>
<li><p>种类</p>
<ul>
<li>行锁 – 在 RC 下，锁住的是行，防止其他事务对此行 update 或 delete</li>
<li>间隙锁 – 在 RR 下，锁住的是间隙，防止其他事务在这个间隙 insert 产生幻读</li>
<li>临键锁 – 在 RR 下，锁住的是前面间隙+行，特定条件下可优化为行锁</li>
</ul>
</li>
<li><p>查看行级锁</p>
<ul>
<li><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks where object_name=&#39;表名&#39;;</code></li>
</ul>
</li>
</ul>
<blockquote>
<p><em><strong>注意</strong></em></p>
<ul>
<li>它们锁定的其实都是<strong>索引</strong>上的行与间隙，根据索引的有序性来确定间隙</li>
</ul>
</blockquote>
<p>测试数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t (id <span class="type">int</span> <span class="keyword">primary</span> key, name <span class="type">varchar</span>(<span class="number">10</span>),age <span class="type">int</span>, key (name)); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">18</span>); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;lisi&#x27;</span>,<span class="number">20</span>); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;wangwu&#x27;</span>,<span class="number">21</span>); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">17</span>); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">8</span>,<span class="string">&#x27;zhang&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">12</span>,<span class="string">&#x27;zhang&#x27;</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong></p>
<ul>
<li>1,2,3,4 之间其实并不可能有间隙</li>
<li>4 与 8 之间有间隙</li>
<li>8 与 12 之间有间隙</li>
<li>12 与正无穷大之间有间隙</li>
<li>其实我们的例子中还有负无穷大与 1 之间的间隙，想避免负数可以通过建表时选择数据类型为 unsigned int</li>
</ul>
</blockquote>
<p>间隙锁例子</p>
<p>事务1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">9</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">/* 锁住的是 8 与 12 之间的间隙 */</span></span><br></pre></td></tr></table></figure>

<p>事务2：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> age<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">8</span>; <span class="comment">/* 不会阻塞 */</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> age<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">12</span>; <span class="comment">/* 不会阻塞 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">10</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="number">18</span>); <span class="comment">/* 会阻塞 */</span></span><br></pre></td></tr></table></figure>



<p>临键锁和记录锁例子</p>
<p>事务1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>临键锁锁定的是左开右闭的区间，与上条查询条件相关的区间有 (4,8]，(8,12]，(12,+∞)</li>
<li>临键锁在某些条件下可以被优化为记录锁，例如 (4,8] 被优化为只针对 8 的记录锁，前面的区间不会锁住</li>
</ul>
<p>事务2：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="number">18</span>); <span class="comment">/* 不会阻塞 */</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> age<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">8</span>; <span class="comment">/* 会阻塞 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">10</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="number">18</span>); <span class="comment">/* 会阻塞 */</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> age<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">12</span>; <span class="comment">/* 会阻塞 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">13</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="number">18</span>); <span class="comment">/* 会阻塞 */</span></span><br></pre></td></tr></table></figure>

</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mysql/">mysql</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://img.sj33.cn/uploads/allimg/201402/7-14022H14522550.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/19/mysql/jdbc/" title="jdbc"><img class="cover" src="https://i.imgtg.com/2023/03/19/9ad4I.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">jdbc</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/19/mysql/mysql%E9%AB%98%E7%BA%A7/" title="mysql高级"><img class="cover" src="https://img.sj33.cn/uploads/allimg/201402/7-14022H14522550.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">mysql高级</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/18/mysql/mysql%E5%9F%BA%E7%A1%80/" title="mysql基础"><img class="cover" src="https://img.sj33.cn/uploads/allimg/201402/7-14022H14522550.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-18</div><div class="title">mysql基础</div></div></a></div><div><a href="/2023/03/19/mysql/mysql%E9%AB%98%E7%BA%A7/" title="mysql高级"><img class="cover" src="https://img.sj33.cn/uploads/allimg/201402/7-14022H14522550.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-19</div><div class="title">mysql高级</div></div></a></div><div><a href="/2023/03/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6SpringCloud+RabbitMQ+Docker+Redis+%E6%90%9C%E7%B4%A2+%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A8%E6%8A%80%E6%9C%AF%E6%A0%88/%E9%9D%A2%E8%AF%95%E7%AF%87/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" title="微服务常见面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-25</div><div class="title">微服务常见面试题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/touxiang.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">happy</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/rrjjyy"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/rrjjyy" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">数据库篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text">1. 隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BF%AB%E7%85%A7%E8%AF%BB%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">1.2.</span> <span class="toc-text">2. 快照读与当前读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-InnoDB-vs-MyISAM"><span class="toc-number">1.3.</span> <span class="toc-text">3. InnoDB vs MyISAM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.</span> <span class="toc-text">4. 索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%9F%BA%E7%A1%80"><span class="toc-number">1.4.1.</span> <span class="toc-text">索引基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%B8%AD%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">命中索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">5. 查询语句执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-undo-log-%E4%B8%8E-redo-log"><span class="toc-number">1.6.</span> <span class="toc-text">6. undo log 与 redo log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%94%81"><span class="toc-number">1.7.</span> <span class="toc-text">7. 锁</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/26/%E5%BD%B1%E8%A7%86/" title="影视">影视</a><time datetime="2023-04-26T10:13:24.000Z" title="发表于 2023-04-26 18:13:24">2023-04-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/16/%E7%94%B5%E8%84%91%E5%95%86%E5%9F%8E/01%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="01系统概述与环境搭建">01系统概述与环境搭建</a><time datetime="2023-04-16T11:46:03.000Z" title="发表于 2023-04-16 19:46:03">2023-04-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6SpringCloud+RabbitMQ+Docker+Redis+%E6%90%9C%E7%B4%A2+%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A8%E6%8A%80%E6%9C%AF%E6%A0%88/%E9%AB%98%E7%BA%A7%E7%AF%87/RabbitMQ-%E9%AB%98%E7%BA%A7%E7%AF%87/" title="RabbitMQ-高级篇">RabbitMQ-高级篇</a><time datetime="2023-03-25T07:40:59.000Z" title="发表于 2023-03-25 15:40:59">2023-03-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6SpringCloud+RabbitMQ+Docker+Redis+%E6%90%9C%E7%B4%A2+%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A8%E6%8A%80%E6%9C%AF%E6%A0%88/%E9%AB%98%E7%BA%A7%E7%AF%87/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/" title="多级缓存">多级缓存</a><time datetime="2023-03-25T07:39:44.000Z" title="发表于 2023-03-25 15:39:44">2023-03-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6SpringCloud+RabbitMQ+Docker+Redis+%E6%90%9C%E7%B4%A2+%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A8%E6%8A%80%E6%9C%AF%E6%A0%88/%E9%AB%98%E7%BA%A7%E7%AF%87/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/" title="分布式缓存">分布式缓存</a><time datetime="2023-03-25T07:37:45.000Z" title="发表于 2023-03-25 15:37:45">2023-03-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text">居然看到底了😊</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>